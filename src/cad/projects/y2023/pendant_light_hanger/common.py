"""
TODO: eventually move these laser cut helpers to the top level common module
"""
import pathlib
import subprocess
from dataclasses import dataclass

import cv2
import ezdxf
import ezdxf.units
import numpy as np
import solid
from shapely import affinity as shapely_affinity
from shapely import ops as shapely_ops
from shapely.geometry import MultiPolygon, Polygon


def s_poly_to_scad(s_poly):
    if isinstance(s_poly, Polygon):
        s_poly = [s_poly]
    elif isinstance(s_poly, MultiPolygon):
        s_poly = s_poly.geoms

    scad_polys = []

    for poly in s_poly:
        exterior = solid.polygon(
            points=[(x, y) for x, y in poly.exterior.coords],
        )
        interiors = [
            solid.polygon(
                points=[(x, y) for x, y in interior.coords],
            )
            for interior in poly.interiors
        ]

        scad_polys += [
            solid.difference()(
                exterior,
                *interiors,
            )
        ]

    return solid.union()(scad_polys)


def _DFS(polygons, contours, hierarchy, sibling_id, is_outer, siblings):
    while sibling_id != -1:
        contour = contours[sibling_id].squeeze(axis=1)
        if len(contour) >= 3:
            first_child_id = hierarchy[sibling_id][2]
            children = [] if is_outer else None
            _DFS(polygons, contours, hierarchy, first_child_id, not is_outer, children)

            if is_outer:
                polygon = Polygon(contour, holes=children)
                polygons.append(polygon)
            else:
                siblings.append(contour)

        sibling_id = hierarchy[sibling_id][0]


def generate_polygons(contours, hierarchy):
    """Generates a list of Shapely polygons from the contours hirarchy returned by cv2.find_contours().
       The list of polygons is generated by performing a depth-first search on the contours hierarchy tree.
    Parameters
    ----------
    contours : list
      The contours returned by cv2.find_contours()
    hierarchy : list
      The hierarchy returned by cv2.find_contours()
    Returns
    -------
    list
      The list of generated Shapely polygons
    """

    hierarchy = hierarchy[0]
    polygons = []
    _DFS(polygons, contours, hierarchy, 0, True, [])
    return polygons


def skeleton_to_polys(
    lines, im_scale=1.0, blur=5, margin=5, threshold=30, debug_image=False
):
    minx = min([min([x1, x2]) for (x1, y1, v1), (x2, y2, v2) in lines])
    maxx = max([max([x1, x2]) for (x1, y1, v1), (x2, y2, v2) in lines])
    miny = min([min([y1, y2]) for (x1, y1, v1), (x2, y2, v2) in lines])
    maxy = max([max([y1, y2]) for (x1, y1, v1), (x2, y2, v2) in lines])

    def world_to_im_space(x, y):
        return (
            ((x - minx) * im_scale) + margin,
            ((y - miny) * im_scale) + margin,
        )

    def im_to_world_space(x, y):
        return (
            (x - margin) / im_scale + minx,
            (y - margin) / im_scale + miny,
        )

    width, height = world_to_im_space(maxx, maxy)
    width, height = (int(width) + margin, int(height) + margin)

    image = np.zeros((height, width), dtype=np.uint16)

    for line in lines:
        (x1, y1, v1), (x2, y2, v2) = line
        x1, y1 = world_to_im_space(x1, y1)
        x2, y2 = world_to_im_space(x2, y2)

        color_range = np.linspace(v1, v2, int(max(abs(x2 - x1), abs(y2 - y1)) + 1))
        points = list(
            zip(
                np.linspace(x1, x2, len(color_range)),
                np.linspace(y1, y2, len(color_range)),
            )
        )
        for point, color_value in zip(points, color_range):
            x, y = map(int, point)
            image[y, x] = color_value

    if debug_image:
        cv2.imshow("image", image)
        cv2.waitKey(0)

    # Blur
    blurred_image = cv2.GaussianBlur(image, (blur, blur), 0)

    if debug_image:
        cv2.imshow("blurred_image", blurred_image)
        cv2.waitKey(0)

    # Threshold
    _, threshold_image = cv2.threshold(blurred_image, threshold, 255, cv2.THRESH_BINARY)

    # Convert to uint8
    threshold_image = threshold_image.astype(np.uint8)

    # Debug
    # threshold_image = blurred_image

    if debug_image:
        cv2.imshow("threshold_image", threshold_image)
        cv2.waitKey(0)

    # Find contours in the blurred image
    contours, hierarchy = cv2.findContours(
        threshold_image, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE
    )
    # hierarchy = np.squeeze(hierarchy)

    # polys = []
    # for contour in contours:
    #     # Convert the contour to a shapely polygon
    #     contour = np.squeeze(contour)
    #     contour = [im_to_world_space(x, y) for x, y in contour]
    #     contour = Polygon(contour)
    #     polys.append(contour)

    # Define function to merge individual contours into one MultiPolygon
    def merge_polygons(polygon: MultiPolygon, idx: int, add: bool) -> MultiPolygon:
        """
        polygon: Main polygon to which a new polygon is added
        idx: Index of contour
        add: If this contour should be added (True) or subtracted (False)
        """

        # Get contour from global list of contours
        contour = np.squeeze(contours[idx])

        # cv2.findContours() sometimes returns a single point -> skip this case
        if len(contour) > 2:
            # Convert contour to shapely polygon
            contour = [im_to_world_space(x, y) for x, y in contour]
            new_poly = Polygon(contour)

            # Not all polygons are shapely-valid (self intersection, etc.)
            if not new_poly.is_valid:
                # Convert invalid polygon to valid
                new_poly = new_poly.buffer(0)

            # Merge new polygon with the main one
            if add:
                polygon = polygon.union(new_poly)
            else:
                polygon = polygon.difference(new_poly)

        # Check if current polygon has a child
        child_idx = hierarchy[idx][2]
        if child_idx >= 0:
            # Call this function recursively, negate `add` parameter
            polygon = merge_polygons(polygon, child_idx, not add)

        # Check if there is some next polygon at the same hierarchy level
        next_idx = hierarchy[idx][0]
        if next_idx >= 0:
            # Call this function recursively
            polygon = merge_polygons(polygon, next_idx, add)

        return polygon

    # Call the function with an initial empty polygon and start from contour 0
    # polygon = merge_polygons(MultiPolygon(), 0, True)
    # polys = [polygon]

    polys = generate_polygons(contours, hierarchy)

    def convert_poly_to_world_space(poly):
        exterior = [im_to_world_space(x, y) for x, y in poly.exterior.coords]
        interiors = [
            [im_to_world_space(x, y) for x, y in interior.coords]
            for interior in poly.interiors
        ]

        return Polygon(exterior, interiors)

    polys = [convert_poly_to_world_space(poly) for poly in polys]

    return polys


@dataclass
class Part:
    polygon: Polygon
    thickness: float
    translate: list[float] = None
    rotate: tuple[tuple[float, float, float], float] = None
    color: list[int] = None
    layer: str = "default"


class Model:
    def __init__(self, part=None, default_thickness=5):
        if part:
            self.parts = [part]
        else:
            self.parts = []
        self.default_thickness = default_thickness

    def add_poly(
        self,
        polygon,
        rotate=None,
        translate=None,
        thickness=None,
        color=None,
        layer="default",
    ):
        self.parts.append(
            Part(
                polygon=polygon,
                thickness=thickness or self.default_thickness,
                translate=translate,
                rotate=rotate,
                color=color,
                layer=layer,
            )
        )

    @property
    def minx(self):
        return min([part.polygon.bounds[0] for part in self.parts])

    @property
    def maxx(self):
        return max([part.polygon.bounds[2] for part in self.parts])

    @property
    def width(self):
        return self.maxx - self.minx


class MultipartModel:
    def __init__(self, default_thickness=5):
        self.models = []
        self.default_thickness = default_thickness

    @property
    def layers(self):
        return list(set([part.layer for model in self.models for part in model.parts]))

    def add_part(
        self, polygon, rotate=None, translate=None, thickness=None, color=None
    ):
        self.models.append(
            Model(
                Part(
                    polygon=polygon,
                    thickness=thickness or self.default_thickness,
                    translate=translate,
                    rotate=rotate,
                    color=color,
                )
            )
        )

    def add_model(self, model):
        self.models.append(model)

    def render_full(self):
        scad_polys = []
        for model in self.models:
            for part in model.parts:
                poly = solid.linear_extrude(part.thickness)(
                    s_poly_to_scad(part.polygon)
                )
                if part.rotate:
                    poly = solid.rotate(part.rotate[1], part.rotate[0])(poly)

                if part.translate:
                    poly = solid.translate(part.translate)(poly)

                if part.color:
                    poly = solid.color(part.color)(poly)

                scad_polys.append(poly)
        return solid.union()(scad_polys)

    def render_parts(self, dir):
        base_path = pathlib.Path(__file__).parent / dir
        base_path.mkdir(parents=True, exist_ok=True)
        for i, part in enumerate(self.parts):
            scad_object = solid.projection()(
                solid.linear_extrude(10)(s_poly_to_scad(part.polygon))
            )

            part_path = base_path / f"part_{i}.scad"
            part_path.write_text(solid.scad_render(scad_object))

    def render_svgs(self, dir):
        pgm = "C:\Program Files\OpenSCAD\openscad.exe"

        base_path = pathlib.Path(__file__).parent / dir
        for i, part in enumerate(self.parts):
            input_path = base_path / f"part_{i}.scad"
            output_path = base_path / f"part_{i}.svg"
            print(f"Rendering {input_path} to {output_path}")
            subprocess.call([pgm, "-o", output_path, input_path])

    def render_single_svg(self, output_path):
        polys = []
        next_x = 0
        for model in self.models:
            for part in model.parts:
                polys.append(
                    shapely_affinity.translate(
                        part.polygon,
                        next_x,
                        0,
                    ),
                )

            next_x += model.width + 1

        poly = shapely_ops.unary_union(polys)

        pathlib.Path(output_path).write_text(poly._repr_svg_())

    def render_single_dxf(self, output_path):
        doc = ezdxf.new("R2010")

        doc.units = ezdxf.units.MM

        for layer in self.layers:
            doc.layers.new(name=layer)

        msp = doc.modelspace()

        next_x = 0
        for model in self.models:
            for part in model.parts:
                if isinstance(part.polygon, Polygon):
                    polygons = [part.polygon]
                elif isinstance(part.polygon, MultiPolygon):
                    polygons = part.polygon.geoms

                for polygon in polygons:
                    polygon = shapely_affinity.translate(
                        polygon,
                        next_x,
                        0,
                    )

                    msp.add_lwpolyline(
                        list(polygon.exterior.coords),
                        dxfattribs={
                            "layer": part.layer,
                        },
                    )

                    for interior in polygon.interiors:
                        msp.add_lwpolyline(
                            list(interior.coords),
                            dxfattribs={
                                "layer": part.layer,
                            },
                        )

            next_x += model.width + 1

        doc.saveas(output_path)

    def render_dxfs(self, output_path):
        output_path.mkdir(parents=True, exist_ok=True)
        for i, model in enumerate(self.models):
            doc = ezdxf.new("R2010")

            doc.units = ezdxf.units.MM

            msp = doc.modelspace()

            for part in model.parts:
                if isinstance(part.polygon, Polygon):
                    polygons = [part.polygon]
                elif isinstance(part.polygon, MultiPolygon):
                    polygons = part.polygon.geoms

                for polygon in polygons:
                    msp.add_lwpolyline(
                        list(polygon.exterior.coords),
                        dxfattribs={
                            "layer": part.layer,
                        },
                    )

                    for interior in polygon.interiors:
                        msp.add_lwpolyline(
                            list(interior.coords),
                            dxfattribs={
                                "layer": part.layer,
                            },
                        )

            doc.saveas(output_path / f"part_{i}.dxf")
