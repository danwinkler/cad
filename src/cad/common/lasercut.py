"""
TODO: eventually move these laser cut helpers to the top level common module
"""
import pathlib
import subprocess
import typing
from collections import defaultdict
from dataclasses import dataclass

import cv2
import euclid3
import ezdxf
import ezdxf.units
import numpy as np
import rectpack
import solid
import svgwrite
import svgwrite.shapes
import trimesh
from fontTools.ttLib import TTFont
from shapely import affinity as shapely_affinity
from shapely import ops as shapely_ops
from shapely.geometry import (
    GeometryCollection,
    LinearRing,
    LineString,
    MultiPolygon,
    Polygon,
    box,
)
from tqdm import tqdm


def s_poly_to_scad(s_poly):
    if isinstance(s_poly, Polygon):
        s_poly = [s_poly]
    elif isinstance(s_poly, MultiPolygon):
        s_poly = s_poly.geoms

    scad_polys = []

    for poly in s_poly:
        exterior = solid.polygon(
            points=[(x, y) for x, y in poly.exterior.coords],
        )
        interiors = [
            solid.polygon(
                points=[(x, y) for x, y in interior.coords],
            )
            for interior in poly.interiors
        ]

        scad_polys += [
            solid.difference()(
                exterior,
                *interiors,
            )
        ]

    return solid.union()(scad_polys)


def _DFS(polygons, contours, hierarchy, sibling_id, is_outer, siblings):
    while sibling_id != -1:
        contour = contours[sibling_id].squeeze(axis=1)
        if len(contour) >= 3:
            first_child_id = hierarchy[sibling_id][2]
            children = [] if is_outer else None
            _DFS(polygons, contours, hierarchy, first_child_id, not is_outer, children)

            if is_outer:
                polygon = Polygon(contour, holes=children)
                polygons.append(polygon)
            else:
                siblings.append(contour)

        sibling_id = hierarchy[sibling_id][0]


def generate_polygons(contours, hierarchy):
    """Generates a list of Shapely polygons from the contours hirarchy returned by cv2.find_contours().
       The list of polygons is generated by performing a depth-first search on the contours hierarchy tree.
    Parameters
    ----------
    contours : list
      The contours returned by cv2.find_contours()
    hierarchy : list
      The hierarchy returned by cv2.find_contours()
    Returns
    -------
    list
      The list of generated Shapely polygons
    """

    hierarchy = hierarchy[0]
    polygons = []
    _DFS(polygons, contours, hierarchy, 0, True, [])
    return polygons


def skeleton_to_polys(
    lines,
    im_scale=1.0,
    blur=5,
    margin=5,
    threshold=30,
    debug_image=False,
    save_images=None,
):
    minx = min([min([x1, x2]) for (x1, y1, v1), (x2, y2, v2) in lines])
    maxx = max([max([x1, x2]) for (x1, y1, v1), (x2, y2, v2) in lines])
    miny = min([min([y1, y2]) for (x1, y1, v1), (x2, y2, v2) in lines])
    maxy = max([max([y1, y2]) for (x1, y1, v1), (x2, y2, v2) in lines])

    def world_to_im_space(x, y):
        return (
            ((x - minx) * im_scale) + margin,
            ((y - miny) * im_scale) + margin,
        )

    def im_to_world_space(x, y):
        return (
            (x - margin) / im_scale + minx,
            (y - margin) / im_scale + miny,
        )

    width, height = world_to_im_space(maxx, maxy)
    width, height = (int(width) + margin, int(height) + margin)

    image = np.zeros((height, width), dtype=np.uint16)

    for line in lines:
        (x1, y1, v1), (x2, y2, v2) = line
        x1, y1 = world_to_im_space(x1, y1)
        x2, y2 = world_to_im_space(x2, y2)

        color_range = np.linspace(v1, v2, int(max(abs(x2 - x1), abs(y2 - y1)) + 1))
        points = list(
            zip(
                np.linspace(x1, x2, len(color_range)),
                np.linspace(y1, y2, len(color_range)),
            )
        )
        for point, color_value in zip(points, color_range):
            x, y = map(int, point)
            image[y, x] = color_value

    if debug_image:
        cv2.imshow("image", cv2.convertScaleAbs(image))
        cv2.waitKey(0)

    if save_images is not None:
        save_images["line_image"] = image

    # Blur
    blurred_image = cv2.GaussianBlur(image, (blur, blur), 0)

    if debug_image:
        cv2.imshow("blurred_image", blurred_image)
        cv2.waitKey(0)

    if save_images is not None:
        save_images["blurred_image"] = blurred_image

    # Threshold
    _, threshold_image = cv2.threshold(blurred_image, threshold, 255, cv2.THRESH_BINARY)

    # Convert to uint8
    threshold_image = threshold_image.astype(np.uint8)

    if debug_image:
        cv2.imshow("threshold_image", threshold_image)
        cv2.waitKey(0)

    if save_images is not None:
        save_images["threshold_image"] = threshold_image

    # Find contours in the blurred image
    contours, hierarchy = cv2.findContours(
        threshold_image, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE
    )

    polys = generate_polygons(contours, hierarchy)

    def convert_poly_to_world_space(poly):
        exterior = [im_to_world_space(x, y) for x, y in poly.exterior.coords]
        interiors = [
            [im_to_world_space(x, y) for x, y in interior.coords]
            for interior in poly.interiors
        ]

        return Polygon(exterior, interiors)

    polys = [convert_poly_to_world_space(poly) for poly in polys]

    return polys


@dataclass
class Part:
    polygon: Polygon
    thickness: float
    renderer: typing.Any = None
    thickness: float = None
    color: list[int] = None
    layer: str = "default"

    def get_solid(self, model):
        return model.renderer.transform(self.renderer.transform(self.polygon))


class AffineTransformRenderer:
    def __init__(self, thickness=5):
        self.stack = []
        self._thickness = thickness

    def translate(self, x=0, y=0, z=0):
        self.stack.append(solid.translate([x, y, z]))
        return self

    def rotate(self, a, v):
        self.stack.append(solid.rotate(a, v))
        return self

    def thickness(self, thickness):
        self._thickness = thickness
        return self

    def color(self, r, g, b):
        self.stack.append(solid.color((r, g, b)))
        return self

    def transform(self, polygon_or_object):
        if isinstance(polygon_or_object, (Polygon, MultiPolygon)):
            polygon_or_object = solid.linear_extrude(self._thickness)(
                s_poly_to_scad(polygon_or_object)
            )

        for transform in self.stack:
            polygon_or_object = transform(polygon_or_object)

        return polygon_or_object


class Model:
    def __init__(self, part=None, thickness=None):
        if part:
            self.parts = [part]
        else:
            self.parts = []
        self.renderer = AffineTransformRenderer()
        self.thickness = thickness

    def add_poly(
        self,
        polygon,
        renderer=None,
        layer="default",
    ):
        if renderer is None:
            renderer = AffineTransformRenderer()

            if self.thickness:
                renderer.thickness(self.thickness)

        self.parts.append(
            Part(
                polygon=polygon,
                renderer=renderer,
                layer=layer,
            )
        )

        return renderer

    @property
    def minx(self):
        return min([part.polygon.bounds[0] for part in self.parts])

    @property
    def miny(self):
        return min([part.polygon.bounds[1] for part in self.parts])

    @property
    def maxx(self):
        return max([part.polygon.bounds[2] for part in self.parts])

    @property
    def maxy(self):
        return max([part.polygon.bounds[3] for part in self.parts])

    @property
    def bounds(self):
        return self.minx, self.miny, self.maxx, self.maxy

    @property
    def width(self):
        return self.maxx - self.minx

    @property
    def height(self):
        return self.maxy - self.miny

    @property
    def layers(self):
        return list(set([part.layer for part in self.parts]))

    def get_solid(self):
        solids = []
        for part in self.parts:
            solids.append(part.get_solid(self))
        return solid.union()(solids)


class SolidModel:
    def __init__(self):
        # Keep this empty so that we don't confuse the 2D system
        self.parts = []
        self.solids = []
        self.renderer = AffineTransformRenderer()

    def add_solid(self, solid_obj):
        self.solids.append(solid_obj)
        return solid_obj

    def get_solid(self):
        return self.renderer.transform(solid.union()(self.solids))


class MultipartModel:
    def __init__(self, default_thickness=5):
        self.models = []
        self.default_thickness = default_thickness
        self.perimeter_bounds = (0, 0, 600, 300)

    @property
    def layers(self):
        return list(set([part.layer for model in self.models for part in model.parts]))

    def add_part(self, polygon, renderer=None, color=None):
        if renderer is None:
            renderer = AffineTransformRenderer(thickness=self.default_thickness)

        self.models.append(
            Model(
                Part(
                    polygon=polygon,
                    renderer=renderer,
                    color=color,
                )
            )
        )

        return renderer

    def add_model(self, model):
        self.models.append(model)
        return model

    def render_scad(self):
        solids = []
        for model in self.models:
            solids.append(model.get_solid())
        return solid.union()(solids)

    def render_single_svg(self, output_path):
        polys = []
        next_x = 0
        for model in self.models:
            for part in model.parts:
                polys.append(
                    shapely_affinity.translate(
                        part.polygon,
                        next_x,
                        0,
                    ),
                )

            next_x += model.width + 1

        poly = shapely_ops.unary_union(polys)

        pathlib.Path(output_path).write_text(poly._repr_svg_())

    def _write_model_into_modelspace(self, model, msp, layer_to_color):
        def write_polygon_list(part, polygons):
            for polygon in polygons:
                msp.add_lwpolyline(
                    list(polygon.exterior.coords),
                    dxfattribs={
                        "color": layer_to_color[part.layer],
                    },
                )

                for interior in polygon.interiors:
                    msp.add_lwpolyline(
                        list(interior.coords),
                        dxfattribs={
                            "color": layer_to_color[part.layer],
                        },
                    )

        def write_polygon(part, polygon):
            if isinstance(polygon, Polygon):
                write_polygon_list(part, [polygon])
            elif isinstance(polygon, MultiPolygon):
                write_polygon_list(part, polygon.geoms)
            elif isinstance(polygon, LineString):
                msp.add_lwpolyline(
                    list(polygon.coords),
                    dxfattribs={
                        "color": layer_to_color[part.layer],
                    },
                )
            elif isinstance(polygon, GeometryCollection):
                for geom in polygon.geoms:
                    write_polygon(part, geom)

        for part in model.parts:
            write_polygon(part, part.polygon)

    def get_layout(self):
        print("Packing...")
        layout = {}

        rects = []
        bins = [
            (self.perimeter_bounds[2], self.perimeter_bounds[3], float("inf"))
            for _ in range(1)
        ]
        for i, model in enumerate(self.models):
            if len(model.parts) == 0:
                continue

            rects.append(
                (
                    rectpack.float2dec(model.width, 3),
                    rectpack.float2dec(model.height, 3),
                    i,
                )
            )

        packer = rectpack.newPacker()

        for rect in rects:
            packer.add_rect(*rect)

        for bin in bins:
            packer.add_bin(*bin)

        packer.pack()

        packed = packer.rect_list()

        pack_check = []

        for rect in packed:
            b, x, y, w, h, rid = rect
            model = self.models[rid]

            x = float(x)
            y = float(y)
            w = float(w)
            h = float(h)

            print(f"Model {rid} at {x}, {y} {w}x{h}")

            bin = packer[b]

            if (
                bin.width != self.perimeter_bounds[2]
                or bin.height != self.perimeter_bounds[3]
            ):
                # Not sure if this can actually happen
                print("Bin rotated -_-")
                x, y, w, h = y, x, h, w

            shape = box(x, y, x + w, y + h)
            check_shape = shape.buffer(-0.001)
            for other in pack_check:
                if check_shape.intersects(other):
                    raise Exception("Packing failed")

            pack_check.append(shape)

            x_err = model.width - w
            y_err = model.height - h

            rot = 0
            if x_err != 0 or y_err != 0:
                # The rectangle must be rotated
                rot = -90

            x_pos = x + b * self.perimeter_bounds[2]

            if rot > 0:
                x_pos += h

            layout[model] = (x_pos, y, rot)

        return layout

    def render_single_dxf(self, output_path):
        doc = ezdxf.new("R2010")

        doc.units = ezdxf.units.MM

        for layer in self.layers:
            doc.layers.add(name=layer)

        msp = doc.modelspace()

        layout = self.get_layout()

        for i, model in enumerate(self.models):
            if len(model.parts) == 0:
                continue

            x, y, rot = layout[model]

            for part in model.parts:
                if isinstance(part.polygon, Polygon):
                    polygons = [part.polygon]
                elif isinstance(part.polygon, MultiPolygon):
                    polygons = part.polygon.geoms

                for polygon in polygons:
                    polygon = shapely_affinity.translate(
                        shapely_affinity.rotate(polygon, rot, origin=(0, 0)),
                        x,
                        y,
                    )

                    msp.add_lwpolyline(
                        list(polygon.exterior.coords),
                        dxfattribs={"color": i},
                    )

                    for interior in polygon.interiors:
                        msp.add_lwpolyline(
                            list(interior.coords),
                            dxfattribs={"color": i},
                        )

        doc.saveas(output_path)

    def render_parts(self, output_path):
        """
        So XTool's software doesn't really like DXF layers, but works great with "layers" specified by color, which it then converts into
        its own layer representation. So we'll just use colors to represent layers.
        """
        output_path.mkdir(parents=True, exist_ok=True)
        for i, model in enumerate(self.models):
            if hasattr(model, "solids"):
                # TODO: make each model class responsible for rendering itself
                with open(output_path / f"part_{i}.scad", "w") as f:
                    f.write(solid.scad_render(model.get_solid()))

            if len(model.parts) == 0:
                continue

            doc = ezdxf.new("R2018")

            doc.units = ezdxf.units.MM

            msp = doc.modelspace()

            layer_to_color = {layer: i for i, layer in enumerate(model.layers)}

            self._write_model_into_modelspace(model, msp, layer_to_color)

            doc.saveas(output_path / f"part_{i}.dxf")

    def render_svgs(self, output_path):
        output_path.mkdir(parents=True, exist_ok=True)
        for i, model in enumerate(self.models):
            if len(model.parts) == 0:
                continue

            dwg = svgwrite.Drawing(
                output_path / f"part_{i}.svg", size=("100mm", "100mm")
            )

            layer_to_color = {layer: i for i, layer in enumerate(model.layers)}

            for part in model.parts:
                if isinstance(part.polygon, Polygon):
                    polygons = [part.polygon]
                elif isinstance(part.polygon, MultiPolygon):
                    polygons = part.polygon.geoms

                for polygon in polygons:
                    dwg.add(svgwrite.shapes.Polygon(list(polygon.exterior.coords)))

                    for interior in polygon.interiors:
                        dwg.add(svgwrite.shapes.Polygon(list(interior.coords)))

            dwg.save()

    def get_total_cut_length(self):
        total = 0

        for model in self.models:
            for part in model.parts:
                if isinstance(part.polygon, Polygon):
                    polygons = [part.polygon]
                elif isinstance(part.polygon, MultiPolygon):
                    polygons = part.polygon.geoms

                for polygon in polygons:
                    total += polygon.exterior.length
                    for interior in polygon.interiors:
                        total += interior.length

        return total


def get_text_polygon(text):
    """
    For a given string returns a shapely polygon representing the text.

    Kind of ugly because I'm doing character layout myself

    TODO: allow specifying font size in mm
    """
    ttf_font = TTFont(str(pathlib.Path(__file__).parent / "Roboto-Regular.ttf"))

    # Create an empty list to store the glyph shapes
    glyph_shapes = []
    cur_x = 0

    # Iterate through each character in the text
    for char in text:
        glyph_name = ttf_font.getBestCmap()[ord(char)]
        glyph = ttf_font["glyf"][glyph_name]

        # # Extract the glyph's contours
        # if hasattr(glyph, "components"):
        #     # If the glyph has components, flatten them to a simple outline
        #     glyph = glyph.getCompositeGlyph()

        # Try to flatten the glyph to a simple outline
        try:
            glyph = glyph.getCompositeGlyph()
        except:
            pass

        contour, indicies, flags = glyph.getCoordinates(ttf_font["glyf"])

        polygon = None
        cur_poly = []
        for i, coord in enumerate(contour):
            cur_poly.append((coord[0], coord[1]))

            if i in indicies:
                if polygon is None:
                    polygon = Polygon(cur_poly)
                else:
                    new_poly = LinearRing(cur_poly)

                    # TTF fonts define negative space as being CCW
                    if new_poly.is_ccw:
                        polygon -= Polygon(cur_poly)
                    else:
                        polygon = shapely_ops.unary_union([polygon, Polygon(cur_poly)])

                cur_poly = []

        if polygon is None:
            cur_x += 1000  # TODO: figure out how to get the width of a whitespace
        else:
            polygon = shapely_affinity.translate(polygon, cur_x, 0)
            cur_x = polygon.bounds[2]
            glyph_shapes.append(polygon)

    # Combine the individual glyph shapes into a MultiPolygon
    final_shape = shapely_ops.unary_union(glyph_shapes)

    return final_shape


class BendyRenderer(AffineTransformRenderer):
    def __init__(self, path, thickness=5, x_offset=0):
        super().__init__(thickness=thickness)
        if isinstance(path, Polygon):
            path = path.exterior.coords
        self.path = path
        self.x_offset = x_offset

    def _extrude_polygon(self, polygon, height):
        if isinstance(polygon, Polygon):
            polys = [polygon]
        elif isinstance(polygon, MultiPolygon):
            polys = polygon.geoms

        vf = [
            trimesh.creation.triangulate_polygon(p, triangle_args="qpa0.1")
            for p in polys
        ]

        v, f = trimesh.util.append_faces([i[0] for i in vf], [i[1] for i in vf])

        mesh = trimesh.creation.extrude_triangulation(v, f, height)

        return mesh

    def bend_points(self, points, path):
        total_path_length = 0
        for i in range(1, len(path)):
            total_path_length += (
                euclid3.Vector2(*path[i]) - euclid3.Vector2(*path[i - 1])
            ).magnitude()

        @dataclass
        class PathData:
            a: list
            b: list
            vec: euclid3.Vector2
            vec_norm: euclid3.Vector2
            vec_cross: euclid3.Vector2
            mag: float

        cache = {}

        def mutate(p):
            x, y, z = p

            x += total_path_length - self.x_offset

            # x becomes the distance along the path
            total_dist = 0
            start_pos = None
            cross = None

            for i in range(1, len(path) * 3):
                key = i % len(path)
                if key not in cache:
                    a = path[(i - 1) % len(path)]
                    b = path[i % len(path)]

                    vec = euclid3.Vector2(*b) - euclid3.Vector2(*a)
                    mag = vec.magnitude()
                    if mag:
                        vec_norm = euclid3.Vector2(vec.x / mag, vec.y / mag)
                    else:
                        vec_norm = vec.copy()
                    cross = vec_norm.cross()

                    data = PathData(
                        a=a,
                        b=b,
                        vec=vec,
                        vec_norm=vec_norm,
                        vec_cross=cross,
                        mag=mag,
                    )
                    cache[key] = data
                else:
                    data = cache[key]

                x_on_d = x - total_dist

                if x_on_d <= data.mag:
                    vec = data.vec_norm.copy()
                    vec *= float(x_on_d)
                    start_pos = [data.a[0] + vec.x, data.a[1] + vec.y]
                    cross = data.vec_cross
                    break

                total_dist += data.mag

            if not start_pos:
                raise Exception("Point not found")

            new_x = start_pos[0] + cross.x * z
            new_y = start_pos[1] + cross.y * z
            new_z = y

            return [new_x, new_y, new_z]

        return [mutate(p) for p in tqdm(points)]

    def transform(self, polygon_or_object):
        assert isinstance(polygon_or_object, (Polygon, MultiPolygon))

        # Step 1: Extrude polygon to a mesh
        mesh = self._extrude_polygon(polygon_or_object, self._thickness)

        # Step 2: Subdivide mesh so that there are enough points to bend around corners
        # TODO: make this customizable
        max_edge = (polygon_or_object.bounds[2] - polygon_or_object.bounds[0]) / 20
        v, f = trimesh.remesh.subdivide_to_size(
            mesh.vertices, mesh.faces, max_edge=max_edge
        )
        mesh = trimesh.Trimesh(vertices=v, faces=f)

        # Step 3: Bend Mesh
        bent_vertices = self.bend_points(mesh.vertices, self.path)

        # Step 4: Construct a solid polyhedron
        polyhedron = solid.polyhedron(points=bent_vertices, faces=mesh.faces)

        return super().transform(polyhedron)


def shapely_to_solid(polygon):
    if isinstance(polygon, Polygon):
        polygon = [polygon]
    elif isinstance(polygon, MultiPolygon):
        polygon = polygon.geoms

    scad_polys = []

    for poly in polygon:
        exterior = solid.polygon(
            points=[(x, y) for x, y in poly.exterior.coords],
        )
        interiors = [
            solid.polygon(
                points=[(x, y) for x, y in interior.coords],
            )
            for interior in poly.interiors
        ]

        scad_polys += [
            solid.difference()(
                exterior,
                *interiors,
            )
        ]

    return solid.union()(scad_polys)
