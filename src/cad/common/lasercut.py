"""
TODO: eventually move these laser cut helpers to the top level common module
"""
import pathlib
import subprocess
from dataclasses import dataclass

import cv2
import ezdxf
import ezdxf.units
import numpy as np
import solid
import svgwrite
import svgwrite.shapes
from fontTools.ttLib import TTFont
from shapely import affinity as shapely_affinity
from shapely import ops as shapely_ops
from shapely.geometry import LinearRing, MultiPolygon, Polygon


def s_poly_to_scad(s_poly):
    if isinstance(s_poly, Polygon):
        s_poly = [s_poly]
    elif isinstance(s_poly, MultiPolygon):
        s_poly = s_poly.geoms

    scad_polys = []

    for poly in s_poly:
        exterior = solid.polygon(
            points=[(x, y) for x, y in poly.exterior.coords],
        )
        interiors = [
            solid.polygon(
                points=[(x, y) for x, y in interior.coords],
            )
            for interior in poly.interiors
        ]

        scad_polys += [
            solid.difference()(
                exterior,
                *interiors,
            )
        ]

    return solid.union()(scad_polys)


def _DFS(polygons, contours, hierarchy, sibling_id, is_outer, siblings):
    while sibling_id != -1:
        contour = contours[sibling_id].squeeze(axis=1)
        if len(contour) >= 3:
            first_child_id = hierarchy[sibling_id][2]
            children = [] if is_outer else None
            _DFS(polygons, contours, hierarchy, first_child_id, not is_outer, children)

            if is_outer:
                polygon = Polygon(contour, holes=children)
                polygons.append(polygon)
            else:
                siblings.append(contour)

        sibling_id = hierarchy[sibling_id][0]


def generate_polygons(contours, hierarchy):
    """Generates a list of Shapely polygons from the contours hirarchy returned by cv2.find_contours().
       The list of polygons is generated by performing a depth-first search on the contours hierarchy tree.
    Parameters
    ----------
    contours : list
      The contours returned by cv2.find_contours()
    hierarchy : list
      The hierarchy returned by cv2.find_contours()
    Returns
    -------
    list
      The list of generated Shapely polygons
    """

    hierarchy = hierarchy[0]
    polygons = []
    _DFS(polygons, contours, hierarchy, 0, True, [])
    return polygons


def skeleton_to_polys(
    lines, im_scale=1.0, blur=5, margin=5, threshold=30, debug_image=False
):
    minx = min([min([x1, x2]) for (x1, y1, v1), (x2, y2, v2) in lines])
    maxx = max([max([x1, x2]) for (x1, y1, v1), (x2, y2, v2) in lines])
    miny = min([min([y1, y2]) for (x1, y1, v1), (x2, y2, v2) in lines])
    maxy = max([max([y1, y2]) for (x1, y1, v1), (x2, y2, v2) in lines])

    def world_to_im_space(x, y):
        return (
            ((x - minx) * im_scale) + margin,
            ((y - miny) * im_scale) + margin,
        )

    def im_to_world_space(x, y):
        return (
            (x - margin) / im_scale + minx,
            (y - margin) / im_scale + miny,
        )

    width, height = world_to_im_space(maxx, maxy)
    width, height = (int(width) + margin, int(height) + margin)

    image = np.zeros((height, width), dtype=np.uint16)

    for line in lines:
        (x1, y1, v1), (x2, y2, v2) = line
        x1, y1 = world_to_im_space(x1, y1)
        x2, y2 = world_to_im_space(x2, y2)

        color_range = np.linspace(v1, v2, int(max(abs(x2 - x1), abs(y2 - y1)) + 1))
        points = list(
            zip(
                np.linspace(x1, x2, len(color_range)),
                np.linspace(y1, y2, len(color_range)),
            )
        )
        for point, color_value in zip(points, color_range):
            x, y = map(int, point)
            image[y, x] = color_value

    if debug_image:
        cv2.imshow("image", image)
        cv2.waitKey(0)

    # Blur
    blurred_image = cv2.GaussianBlur(image, (blur, blur), 0)

    if debug_image:
        cv2.imshow("blurred_image", blurred_image)
        cv2.waitKey(0)

    # Threshold
    _, threshold_image = cv2.threshold(blurred_image, threshold, 255, cv2.THRESH_BINARY)

    # Convert to uint8
    threshold_image = threshold_image.astype(np.uint8)

    # Debug
    # threshold_image = blurred_image

    if debug_image:
        cv2.imshow("threshold_image", threshold_image)
        cv2.waitKey(0)

    # Find contours in the blurred image
    contours, hierarchy = cv2.findContours(
        threshold_image, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE
    )
    # hierarchy = np.squeeze(hierarchy)

    # polys = []
    # for contour in contours:
    #     # Convert the contour to a shapely polygon
    #     contour = np.squeeze(contour)
    #     contour = [im_to_world_space(x, y) for x, y in contour]
    #     contour = Polygon(contour)
    #     polys.append(contour)

    # Define function to merge individual contours into one MultiPolygon
    def merge_polygons(polygon: MultiPolygon, idx: int, add: bool) -> MultiPolygon:
        """
        polygon: Main polygon to which a new polygon is added
        idx: Index of contour
        add: If this contour should be added (True) or subtracted (False)
        """

        # Get contour from global list of contours
        contour = np.squeeze(contours[idx])

        # cv2.findContours() sometimes returns a single point -> skip this case
        if len(contour) > 2:
            # Convert contour to shapely polygon
            contour = [im_to_world_space(x, y) for x, y in contour]
            new_poly = Polygon(contour)

            # Not all polygons are shapely-valid (self intersection, etc.)
            if not new_poly.is_valid:
                # Convert invalid polygon to valid
                new_poly = new_poly.buffer(0)

            # Merge new polygon with the main one
            if add:
                polygon = polygon.union(new_poly)
            else:
                polygon = polygon.difference(new_poly)

        # Check if current polygon has a child
        child_idx = hierarchy[idx][2]
        if child_idx >= 0:
            # Call this function recursively, negate `add` parameter
            polygon = merge_polygons(polygon, child_idx, not add)

        # Check if there is some next polygon at the same hierarchy level
        next_idx = hierarchy[idx][0]
        if next_idx >= 0:
            # Call this function recursively
            polygon = merge_polygons(polygon, next_idx, add)

        return polygon

    # Call the function with an initial empty polygon and start from contour 0
    # polygon = merge_polygons(MultiPolygon(), 0, True)
    # polys = [polygon]

    polys = generate_polygons(contours, hierarchy)

    def convert_poly_to_world_space(poly):
        exterior = [im_to_world_space(x, y) for x, y in poly.exterior.coords]
        interiors = [
            [im_to_world_space(x, y) for x, y in interior.coords]
            for interior in poly.interiors
        ]

        return Polygon(exterior, interiors)

    polys = [convert_poly_to_world_space(poly) for poly in polys]

    return polys


@dataclass
class Part:
    polygon: Polygon
    thickness: float
    translate: list[float] = None
    rotate: tuple[tuple[float, float, float], float] = None
    color: list[int] = None
    layer: str = "default"


class Model:
    def __init__(self, part=None, thickness=None):
        if part:
            self.parts = [part]
        else:
            self.parts = []
        self.thickness = thickness
        self.rotate = None
        self.translate = None
        self.thickness = None
        self.color = None

    def add_poly(
        self,
        polygon,
        rotate=None,
        translate=None,
        thickness=None,
        color=None,
        layer="default",
    ):
        self.parts.append(
            Part(
                polygon=polygon,
                thickness=thickness or self.thickness,
                translate=translate,
                rotate=rotate,
                color=color,
                layer=layer,
            )
        )

    @property
    def minx(self):
        return min([part.polygon.bounds[0] for part in self.parts])

    @property
    def maxx(self):
        return max([part.polygon.bounds[2] for part in self.parts])

    @property
    def width(self):
        return self.maxx - self.minx

    @property
    def layers(self):
        return list(set([part.layer for part in self.parts]))


class MultipartModel:
    def __init__(self, default_thickness=5):
        self.models = []
        self.default_thickness = default_thickness

    @property
    def layers(self):
        return list(set([part.layer for model in self.models for part in model.parts]))

    def add_part(
        self, polygon, rotate=None, translate=None, thickness=None, color=None
    ):
        self.models.append(
            Model(
                Part(
                    polygon=polygon,
                    thickness=thickness or self.default_thickness,
                    translate=translate,
                    rotate=rotate,
                    color=color,
                )
            )
        )

    def add_model(self, model):
        self.models.append(model)

    def render_full(self):
        scad_polys = []
        for model in self.models:
            for part in model.parts:
                thickness = part.thickness or model.thickness or self.default_thickness
                poly = solid.linear_extrude(thickness)(s_poly_to_scad(part.polygon))
                if model.rotate:
                    poly = solid.rotate(model.rotate[1], model.rotate[0])(poly)

                if part.rotate:
                    poly = solid.rotate(part.rotate[1], part.rotate[0])(poly)

                if model.translate:
                    poly = solid.translate(model.translate)(poly)

                if part.translate:
                    poly = solid.translate(part.translate)(poly)

                if model.color:
                    poly = solid.color(model.color)(poly)

                if part.color:
                    poly = solid.color(part.color)(poly)

                scad_polys.append(poly)
        return solid.union()(scad_polys)

    def render_parts(self, dir):
        base_path = pathlib.Path(__file__).parent / dir
        base_path.mkdir(parents=True, exist_ok=True)
        for i, part in enumerate(self.parts):
            scad_object = solid.projection()(
                solid.linear_extrude(10)(s_poly_to_scad(part.polygon))
            )

            part_path = base_path / f"part_{i}.scad"
            part_path.write_text(solid.scad_render(scad_object))

    def render_svgs(self, dir):
        pgm = "C:\Program Files\OpenSCAD\openscad.exe"

        base_path = pathlib.Path(__file__).parent / dir
        for i, part in enumerate(self.parts):
            input_path = base_path / f"part_{i}.scad"
            output_path = base_path / f"part_{i}.svg"
            print(f"Rendering {input_path} to {output_path}")
            subprocess.call([pgm, "-o", output_path, input_path])

    def render_single_svg(self, output_path):
        polys = []
        next_x = 0
        for model in self.models:
            for part in model.parts:
                polys.append(
                    shapely_affinity.translate(
                        part.polygon,
                        next_x,
                        0,
                    ),
                )

            next_x += model.width + 1

        poly = shapely_ops.unary_union(polys)

        pathlib.Path(output_path).write_text(poly._repr_svg_())

    def render_single_dxf(self, output_path):
        doc = ezdxf.new("R2010")

        doc.units = ezdxf.units.MM

        for layer in self.layers:
            doc.layers.add(name=layer)

        msp = doc.modelspace()

        next_x = 0
        for model in self.models:
            for part in model.parts:
                if isinstance(part.polygon, Polygon):
                    polygons = [part.polygon]
                elif isinstance(part.polygon, MultiPolygon):
                    polygons = part.polygon.geoms

                for polygon in polygons:
                    polygon = shapely_affinity.translate(
                        polygon,
                        next_x,
                        0,
                    )

                    msp.add_lwpolyline(
                        list(polygon.exterior.coords),
                        dxfattribs={
                            "layer": part.layer,
                        },
                    )

                    for interior in polygon.interiors:
                        msp.add_lwpolyline(
                            list(interior.coords),
                            dxfattribs={
                                "layer": part.layer,
                            },
                        )

            next_x += model.width + 1

        doc.saveas(output_path)

    def render_dxfs(self, output_path):
        """
        So XTool's software doesn't really like DXF layers, but works great with "layers" specified by color, which it then converts into
        its own layer representation. So we'll just use colors to represent layers.
        """
        output_path.mkdir(parents=True, exist_ok=True)
        for i, model in enumerate(self.models):
            doc = ezdxf.new("R2018")

            doc.units = ezdxf.units.MM

            msp = doc.modelspace()

            layer_to_color = {layer: i for i, layer in enumerate(model.layers)}

            # for i, layer in enumerate(model.layers):
            #     doc.layers.add(
            #         name=layer,
            #         # color=i + 1,
            #         # true_color=layer_to_color[layer],
            #     )

            for part in model.parts:
                if isinstance(part.polygon, Polygon):
                    polygons = [part.polygon]
                elif isinstance(part.polygon, MultiPolygon):
                    polygons = part.polygon.geoms

                for polygon in polygons:
                    msp.add_lwpolyline(
                        list(polygon.exterior.coords),
                        dxfattribs={
                            # "layer": part.layer,
                            "color": layer_to_color[part.layer],
                        },
                    )

                    for interior in polygon.interiors:
                        msp.add_lwpolyline(
                            list(interior.coords),
                            dxfattribs={
                                # "layer": part.layer,
                                "color": layer_to_color[part.layer],
                            },
                        )

            doc.saveas(output_path / f"part_{i}.dxf")

    def render_svgs(self, output_path):
        output_path.mkdir(parents=True, exist_ok=True)
        for i, model in enumerate(self.models):
            dwg = svgwrite.Drawing(
                output_path / f"part_{i}.svg", size=("100mm", "100mm")
            )

            layer_to_color = {layer: i for i, layer in enumerate(model.layers)}

            for part in model.parts:
                if isinstance(part.polygon, Polygon):
                    polygons = [part.polygon]
                elif isinstance(part.polygon, MultiPolygon):
                    polygons = part.polygon.geoms

                for polygon in polygons:
                    dwg.add(svgwrite.shapes.Polygon(list(polygon.exterior.coords)))

                    for interior in polygon.interiors:
                        dwg.add(svgwrite.shapes.Polygon(list(interior.coords)))

            dwg.save()

    def get_total_cut_length(self):
        total = 0

        for model in self.models:
            for part in model.parts:
                if isinstance(part.polygon, Polygon):
                    polygons = [part.polygon]
                elif isinstance(part.polygon, MultiPolygon):
                    polygons = part.polygon.geoms

                for polygon in polygons:
                    total += polygon.exterior.length
                    for interior in polygon.interiors:
                        total += interior.length

        return total


def get_text_polygon(text):
    """
    For a given string returns a shapely polygon representing the text.

    Kind of ugly because I'm doing character layout myself

    TODO: allow specifying font size in mm
    """
    ttf_font = TTFont(str(pathlib.Path(__file__).parent / "Roboto-Regular.ttf"))

    # Create an empty list to store the glyph shapes
    glyph_shapes = []
    cur_x = 0

    # Iterate through each character in the text
    for char in text:
        glyph_name = ttf_font.getBestCmap()[ord(char)]
        glyph = ttf_font["glyf"][glyph_name]

        # Extract the glyph's contours
        if hasattr(glyph, "components"):
            # If the glyph has components, flatten them to a simple outline
            glyph = glyph.getCompositeGlyph()

        contour, indicies, flags = glyph.getCoordinates(ttf_font["glyf"])

        polygon = None
        cur_poly = []
        for i, coord in enumerate(contour):
            cur_poly.append((coord[0], coord[1]))

            if i in indicies:
                if polygon is None:
                    polygon = Polygon(cur_poly)
                else:
                    new_poly = LinearRing(cur_poly)

                    # TTF fonts define negative space as being CCW
                    if new_poly.is_ccw:
                        polygon -= Polygon(cur_poly)
                    else:
                        polygon = shapely_ops.unary_union([polygon, Polygon(cur_poly)])

                cur_poly = []

        polygon = shapely_affinity.translate(polygon, cur_x, 0)
        cur_x = polygon.bounds[2]

        glyph_shapes.append(polygon)

    # Combine the individual glyph shapes into a MultiPolygon
    multipolygon = MultiPolygon(glyph_shapes)

    return multipolygon
